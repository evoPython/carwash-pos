from flask import Flask, render_template, request, jsonify, redirect, url_for, flash
from flask_login import login_user, logout_user, login_required, current_user
from config import Config
from db import (init_db, add_order, start_sync_thread, get_db,
                get_user_by_username, create_user, get_all_users,
                get_user_by_id, update_user_role, activate_user,
                deactivate_user, change_user_password, update_user_shift,
                add_shift_summary, get_shift_summary, get_all_shift_summaries)
from db.models import Order, User, Role
from auth import (init_auth, authenticate_user, require_login,
                  require_admin, require_developer, get_redirect_target)
import pytz
from datetime import datetime, time, timedelta

def create_app():
    app = Flask(__name__, static_folder="static", template_folder="templates")
    app.config.from_object(Config)
    
    # Configure session settings for better persistence
    app.permanent_session_lifetime = app.config['PERMANENT_SESSION_LIFETIME']

    # Initialize authentication
    init_auth(app)

    init_db()
    if Config.SYNC_ENABLED:
        start_sync_thread()

    # ============================================
    # AUTHENTICATION ROUTES
    # ============================================
    
    @app.route("/login", methods=["GET", "POST"])
    def login():
        """User login route."""
        if current_user.is_authenticated:
            return redirect(url_for('index'))

        if request.method == "POST":
            username = request.form.get('username')
            password = request.form.get('password')
            remember_me = bool(request.form.get('remember_me'))

            if not username or not password:
                flash('Please enter both username and password.', 'error')
                return render_template('login.html')

            user = authenticate_user(username, password)
            if user:
                login_user(user, remember=remember_me)
                if remember_me:
                    from flask import session
                    session.permanent = True

                # Redirect directly to dashboard (no welcome message)
                next_page = get_redirect_target()
                if next_page and 'login' not in next_page and 'register' not in next_page:
                    return redirect(next_page)
                return redirect(url_for('index'))
            else:
                flash('Invalid username or password.', 'error')
                return render_template('login.html')

        return render_template('login.html')
    
    @app.route("/register", methods=["GET", "POST"])
    def register():
        """User registration route."""
        if current_user.is_authenticated:
            return redirect(url_for('index'))
        
        if request.method == "POST":
            username = request.form.get('username')
            full_name = request.form.get('full_name')
            password = request.form.get('password')
            confirm_password = request.form.get('confirm_password')
            role = request.form.get('role')
            shift = request.form.get('shift')
            
            # Validation
            if not all([username, full_name, password, confirm_password, role]):
                flash('All fields are required.', 'error')
                return render_template('register.html')
            
            if password != confirm_password:
                flash('Passwords do not match.', 'error')
                return render_template('register.html')
            
            if len(password) < 6:
                flash('Password must be at least 6 characters long.', 'error')
                return render_template('register.html')
            
            if role not in Role.get_all_roles():
                flash('Invalid role selected.', 'error')
                return render_template('register.html')
            
            # For incharges, shift is required
            if role == 'Incharge' and (not shift or shift == ''):
                flash('Shift selection is required for Incharge role.', 'error')
                return render_template('register.html')
            
            # Validate shift value
            if shift and shift not in ['AM', 'PM']:
                flash('Invalid shift selected.', 'error')
                return render_template('register.html')
            
            try:
                user_id = create_user(username, full_name, password, role, shift)
                flash('Account created successfully! You can now log in.', 'success')
                return redirect(url_for('login'))
            except ValueError as e:
                flash(str(e), 'error')
        
        return render_template('register.html')
    
    @app.route("/logout")
    def logout():
        """User logout route."""
        logout_user()
        return redirect(url_for('login'))

    # ============================================
    # MAIN APPLICATION ROUTES
    # ============================================

    @app.route("/")
    @require_login
    def index():
        """Main dashboard - requires login."""
        # Allow all users to access the dashboard
        
        return render_template("index.html")
    
    @app.route("/users")
    @require_admin
    def users():
        """User management page - requires admin access."""
        return render_template("users.html")

    @app.route("/summary")
    @require_admin
    def summary():
        """Summary dashboard - requires admin/developer access."""
        return render_template("summary.html")

    # ============================================
    # ORDER API ROUTES (Protected)
    # ============================================
    
    @app.route("/api/orders", methods=["POST"])
    @require_login
    def api_add_order():
        """Add new order - requires login."""
        data = request.get_json()
        if not data:
            return jsonify({"error": "invalid JSON"}), 400
        oid = add_order(data)
        return jsonify({"status": "ok", "id": oid}), 201

    @app.route("/api/orders", methods=["GET"])
    @require_login
    def api_list_orders():
        """List orders - requires login with role-based filtering.

        - Non-admin/dev users: show orders where w_name == current_user.full_name
        AND timestamp is within current user's current shift window.
        - Admin/dev users: if both 'date' and 'shift' query params are provided,
        show orders only for that shift/window on that date (regardless of w_name).
        Otherwise, admin/dev users may use optional date/month filters as before.
        """
        # Base query for new order structure
        clause = """
            SELECT id, vehicle_name, plate_no, w_vac, addons, price, less_40,
                c_shares, w_share, w_name, sss, timestamp, shift, created_by
            FROM orders
            WHERE 1=1
        """
        params = []

        # Query params
        date_param = request.args.get("date")   # expected format: "YYYY-MM-DD"
        month_param = request.args.get("month") # expected format: "YYYY-MM"
        shift_param = request.args.get("shift") # expected: "AM" or "PM"

        # Determine user role & name
        current_user_full_name = current_user.full_name
        current_user_role      = current_user.role
        is_admin_or_dev        = current_user_role in ['Admin', 'Developer']

        # If admin/dev AND they provided BOTH date AND shift -> compute explicit shift window for that date
        if is_admin_or_dev and date_param and shift_param:
            # Validate shift_param
            shift_param = shift_param.upper()
            if shift_param not in ('AM', 'PM'):
                return jsonify({"error": "Invalid shift parameter; must be 'AM' or 'PM'."}), 400

            # Parse date_param
            try:
                # date_param format: YYYY-MM-DD
                d = datetime.strptime(date_param, "%Y-%m-%d").date()
            except ValueError:
                return jsonify({"error": "Invalid date parameter; must be YYYY-MM-DD."}), 400

            # Build shift window (naive datetimes, matching DB format)
            if shift_param == 'AM':
                # AM: same date 05:00 -> same date 17:00
                shift_start = datetime(d.year, d.month, d.day, 5, 0, 0)
                shift_end   = datetime(d.year, d.month, d.day, 17, 0, 0)
            else:  # PM
                # PM: date 17:00 -> date+1 05:00
                shift_start = datetime(d.year, d.month, d.day, 17, 0, 0)
                next_day = d + timedelta(days=1)
                shift_end   = datetime(next_day.year, next_day.month, next_day.day, 5, 0, 0)

            # Format as naive ISO strings (matches DB: YYYY-MM-DDThh:mm:ss[.ffffff])
            start_str = shift_start.isoformat()
            end_str   = shift_end.isoformat()

            app.logger.debug(f"ADMIN SHIFT WINDOW requested: date={date_param} shift={shift_param}")
            app.logger.debug(f"  START = {start_str}")
            app.logger.debug(f"  END   = {end_str}")

            # Add timestamp BETWEEN clause for that explicit window
            clause += ' AND timestamp BETWEEN ? AND ?'
            params.extend([start_str, end_str])

        else:
            # Non-admin/dev users: restrict to their current shift & their name
            if not is_admin_or_dev:
                user_shift = current_user.shift
                if not user_shift:
                    return jsonify({"error": "No shift assigned"}), 400

                # Current time in Manila to determine which shift window is "current"
                manila_tz = pytz.timezone('Asia/Manila')
                now = datetime.now(manila_tz)

                # Determine current shift window (shift_start, shift_end) as aware datetimes,
                # then strip tzinfo for DB string format (naive)
                if user_shift == 'AM':
                    # AM shift window: today 05:00 -> today 17:00
                    shift_start = now.replace(hour=5, minute=0, second=0, microsecond=0)
                    shift_end   = now.replace(hour=17, minute=0, second=0, microsecond=0)
                else:
                    # PM shift window spans two dates
                    if now.hour >= 17:
                        # we're in today's PM: today 17:00 -> tomorrow 05:00
                        shift_start = now.replace(hour=17, minute=0, second=0, microsecond=0)
                        shift_end   = (now + timedelta(days=1)).replace(hour=5, minute=0, second=0, microsecond=0)
                    elif now.hour < 5:
                        # we're still in overnight PM shift: yesterday 17:00 -> today 05:00
                        shift_start = (now - timedelta(days=1)).replace(hour=17, minute=0, second=0, microsecond=0)
                        shift_end   = now.replace(hour=5, minute=0, second=0, microsecond=0)
                    else:
                        # during daytime hours (05:00-17:00) the most recent PM window was yesterday 17:00->today 05:00
                        shift_start = (now - timedelta(days=1)).replace(hour=17, minute=0, second=0, microsecond=0)
                        shift_end   = now.replace(hour=5, minute=0, second=0, microsecond=0)

                # Strip tzinfo and format naive ISO strings
                shift_start_naive = shift_start.replace(tzinfo=None)
                shift_end_naive   = shift_end.replace(tzinfo=None)
                start_str = shift_start_naive.isoformat()
                end_str   = shift_end_naive.isoformat()

                app.logger.debug(f"USER SHIFT WINDOW for {current_user_full_name} ({user_shift}):")
                app.logger.debug(f"  START = {start_str}")
                app.logger.debug(f"  END   = {end_str}")

                # Add filters: by carwasher name AND timestamp within current shift
                clause += ' AND w_name = ? AND timestamp BETWEEN ? AND ?'
                params.extend([current_user_full_name, start_str, end_str])

            else:
                # Admin/dev without explicit (date+shift): allow optional date/month filters below
                # If the caller provided date/month, apply those filters here.
                if date_param:
                    clause += ' AND DATE(timestamp) = ?'
                    params.append(date_param)
                elif month_param:
                    clause += ' AND strftime("%Y-%m", timestamp) = ?'
                    params.append(month_param)

        # If we reached here and the caller was an admin/dev AND they provided date/month but not the combined (date+shift),
        # the date/month filters were already applied above in the final 'else' branch. For non-admins we already used the
        # current shift window and ignored date/month query params (this matches original behavior).

        # Execute query
        with get_db() as conn:
            app.logger.debug(f"FINAL SQL clause: {clause}")
            app.logger.debug(f"FINAL params: {params}")
            rows = conn.execute(clause, params).fetchall()

        # Marshal results
        orders = []
        for row in rows:
            orders.append({
                'id':           row[0],
                'vehicle_name': row[1],
                'plate_no':     row[2],
                'w_vac':        row[3],
                'addons':       row[4],
                'price':        row[5],
                'less_40':      row[6],
                'c_shares':     row[7],
                'w_share':      row[8],
                'w_name':       row[9],
                'sss':          row[10],
                'timestamp':    row[11],
                'shift':        row[12],
                'created_by':   row[13],
            })
        return jsonify(orders), 200

    @app.route("/api/previous-shift-orders", methods=["GET"])
    @require_login
    def api_previous_shift_orders():
        """Get orders from the user's previous shift - for incharges only."""
        # Only incharges can access this endpoint
        if current_user.role != 'Incharge':
            return jsonify({"error": "Access denied"}), 403

        # Get current user's shift
        user_shift = current_user.shift
        if not user_shift:
            return jsonify({"error": "No shift assigned"}), 400

        # Current time in Manila
        manila_tz = pytz.timezone('Asia/Manila')
        now = datetime.now(manila_tz)

        # Determine previous shift boundaries
        if user_shift == 'AM':
            # AM shift: 05:00–17:00
            if 5 <= now.hour < 17:
                # Currently in AM → last AM was yesterday 05:00–17:00
                start_time = (now - timedelta(days=1)).replace(hour=5, minute=0, second=0, microsecond=0)
                end_time   = (now - timedelta(days=1)).replace(hour=17, minute=0, second=0, microsecond=0)
            elif now.hour >= 17:
                # Currently in PM → last AM was today 05:00–17:00
                start_time = now.replace(hour=5, minute=0, second=0, microsecond=0)
                end_time   = now.replace(hour=17, minute=0, second=0, microsecond=0)
            else:
                # Currently before 05:00 → still in PM from yesterday → last AM was yesterday 05:00–17:00
                start_time = (now - timedelta(days=1)).replace(hour=5, minute=0, second=0, microsecond=0)
                end_time   = (now - timedelta(days=1)).replace(hour=17, minute=0, second=0, microsecond=0)
        else:
            # PM shift: 17:00–05:00
            if now.hour >= 17:
                # Currently in PM → last PM was yesterday 17:00 → today 05:00
                start_time = (now - timedelta(days=1)).replace(hour=17, minute=0, second=0, microsecond=0)
                end_time   = (now + timedelta(days=1)).replace(hour=5, minute=0, second=0, microsecond=0)
            elif now.hour < 5:
                # Currently in the tail end of PM → last PM was two nights ago 17:00 → yesterday 05:00
                start_time = (now - timedelta(days=2)).replace(hour=17, minute=0, second=0, microsecond=0)
                end_time   = (now - timedelta(days=1)).replace(hour=5, minute=0, second=0, microsecond=0)
            else:
                # Currently in AM → last PM was yesterday 17:00 → today 05:00
                start_time = (now - timedelta(days=1)).replace(hour=17, minute=0, second=0, microsecond=0)
                end_time   = now.replace(hour=5, minute=0, second=0, microsecond=0)

        # Strip timezone so format matches DB (naive ISO)
        start_naive = start_time.replace(tzinfo=None)
        end_naive   = end_time.replace(tzinfo=None)
        start_str = start_naive.isoformat()   # e.g. "2025-08-07T05:00:00"
        end_str   = end_naive.isoformat()     # e.g. "2025-08-07T17:00:00"

        # Debug logging
        # app.logger.debug(f"Previous {user_shift} shift for user {current_user.full_name}:")
        # app.logger.debug(f"  START = {start_str}")
        # app.logger.debug(f"  END   = {end_str}")

        # Query orders from previous shift, filtering on shift + full name + timestamp
        clause = """
            SELECT id, vehicle_name, plate_no, w_vac, addons, price, less_40,
                c_shares, w_share, w_name, sss, timestamp, shift, created_by
            FROM orders
            WHERE shift     = ?
            AND w_name    = ?
            AND timestamp BETWEEN ? AND ?
        """

        with get_db() as conn:
            rows = conn.execute(clause, (
                user_shift,
                current_user.full_name,
                start_str,
                end_str
            )).fetchall()

        # app.logger.debug(f"FOUND rows: {rows}")

        # Convert to the expected format
        orders = []
        for row in rows:
            order = {
                'id': row[0],
                'vehicle_name': row[1],
                'plate_no': row[2],
                'w_vac': row[3],
                'addons': row[4],
                'price': row[5],
                'less_40': row[6],
                'c_shares': row[7],
                'w_share': row[8],
                'w_name': row[9],
                'sss': row[10],
                'timestamp': row[11],
                'shift': row[12],
                'created_by': row[13]
            }
            orders.append(order)

        return jsonify(orders), 200


    @app.route("/api/summary", methods=["GET"])
    @require_login
    def api_summary():
        """Get financial summary - admin/dev only."""
        # Only admin/dev can see financial summaries
        if current_user.role == 'Incharge':
            return jsonify({"error": "Access denied"}), 403
        
        date = request.args.get("date")
        month = request.args.get("month")
        
        clause = "SELECT price, c_shares, w_share FROM orders WHERE 1=1"
        params = []
        
        if date:
            clause += ' AND DATE(timestamp) = ?'
            params.append(date)
        elif month:
            clause += ' AND strftime("%Y-%m", timestamp) = ?'
            params.append(month)
        
        with get_db() as conn:
            rows = conn.execute(clause, params).fetchall()
        
        total_income = sum(row[0] for row in rows)
        total_expenses = len(rows) * 40  # LESS 40 per order
        total_cetadcco_share = sum(row[1] for row in rows)
        total_carwasher_share = sum(row[2] for row in rows)

        return jsonify({
            "income": total_income,
            "expenses": total_expenses,
            "cetadcco_share": total_cetadcco_share,
            "carwasher_share": total_carwasher_share
        }), 200

    # ============================================
    # USER MANAGEMENT API ROUTES (Admin Only)
    # ============================================
    
    @app.route("/api/users", methods=["GET"])
    @require_admin
    def api_list_users():
        """List all users - admin only."""
        try:
            users = get_all_users()
            return jsonify([user.to_dict() for user in users]), 200
        except Exception as e:
            return jsonify({"error": str(e)}), 500
    
    @app.route("/api/users/<int:user_id>", methods=["GET"])
    @require_admin
    def api_get_user(user_id):
        """Get specific user - admin only."""
        try:
            user = get_user_by_id(user_id)
            if not user:
                return jsonify({"error": "User not found"}), 404
            return jsonify(user.to_dict()), 200
        except Exception as e:
            return jsonify({"error": str(e)}), 500
    
    @app.route("/api/users/create", methods=["POST"])
    @require_admin
    def api_create_user():
        """Create new user - admin only."""
        try:
            data = request.get_json()
            if not data:
                return jsonify({"error": "No data provided"}), 400

            username = data.get('username')
            full_name = data.get('full_name')
            password = data.get('password')
            role = data.get('role')
            shift = data.get('shift')
            print(f"Role: {role}")

            if not all([username, full_name, password, role]):
                return jsonify({"error": "Missing required fields"}), 400

            if role not in Role.get_all_roles():
                return jsonify({"error": "Invalid role"}), 400

            # For incharges, shift is required
            if role == 'Incharge' and (not shift or shift == ''):
                return jsonify({"error": "Shift is required for Incharge role"}), 400

            user_id = create_user(username, full_name, password, role, shift=shift)
            return jsonify({"message": "User created successfully", "id": user_id}), 201

        except ValueError as e:
            return jsonify({"error": str(e)}), 400
        except Exception as e:
            return jsonify({"error": str(e)}), 500
    
    @app.route("/api/users/update", methods=["POST"])
    @require_admin
    def api_update_user():
        """Update user - admin only."""
        try:
            data = request.get_json()
            if not data:
                return jsonify({"error": "No data provided"}), 400
            
            user_id = data.get('user_id')
            if not user_id:
                return jsonify({"error": "User ID required"}), 400
            
            user = get_user_by_id(user_id)
            if not user:
                return jsonify({"error": "User not found"}), 404
            
            # Update role if provided
            if 'role' in data and data['role'] != user.role:
                if data['role'] not in Role.get_all_roles():
                    return jsonify({"error": "Invalid role"}), 400
                update_user_role(user_id, data['role'])
            
            # Update password if provided
            if 'password' in data and data['password']:
                if len(data['password']) < 6:
                    return jsonify({"error": "Password must be at least 6 characters"}), 400
                change_user_password(user_id, data['password'])
            
            # Update active status if provided
            if 'is_active' in data:
                if data['is_active']:
                    activate_user(user_id)
                else:
                    deactivate_user(user_id)
            
            # Update shift times if provided
            if 'shift_start' in data and 'shift_end' in data:
                update_user_shift(user_id, data['shift_start'], data['shift_end'])
            
            return jsonify({"message": "User updated successfully"}), 200
            
        except Exception as e:
            return jsonify({"error": str(e)}), 500
    
    @app.route("/api/users/<int:user_id>/activate", methods=["POST"])
    @require_admin
    def api_activate_user(user_id):
        """Activate user - admin only."""
        try:
            if activate_user(user_id):
                return jsonify({"message": "User activated successfully"}), 200
            else:
                return jsonify({"error": "User not found"}), 404
        except Exception as e:
            return jsonify({"error": str(e)}), 500
    
    @app.route("/api/users/<int:user_id>/deactivate", methods=["POST"])
    @require_admin
    def api_deactivate_user(user_id):
        """Deactivate user - admin only."""
        try:
            if deactivate_user(user_id):
                return jsonify({"message": "User deactivated successfully"}), 200
            else:
                return jsonify({"error": "User not found"}), 404
        except Exception as e:
            return jsonify({"error": str(e)}), 500

    # ============================================
    # SHIFT SUMMARY API ENDPOINTS
    # ============================================

    @app.route("/api/shift-summary", methods=["POST"])
    @require_login
    def api_submit_shift_summary():
        """Submit shift summary data - InCharge only."""
        try:
            # Only InCharges can submit shift summaries
            if not current_user.is_incharge():
                return jsonify({"error": "Unauthorized. Only InCharges can submit shift summaries."}), 403

            data = request.get_json()
            if not data:
                return jsonify({"error": "No data provided"}), 400

            # Get current date and user's shift
            from datetime import datetime
            current_time = datetime.now()
            current_date = current_time.strftime('%Y-%m-%d')
            
            # Determine shift based on current time or use user's shift
            user_shift = current_user.shift
            if not user_shift:
                # Fallback to time-based shift determination
                user_shift = "AM" if 5 <= current_time.hour < 17 else "PM"

            # Extract form data
            summary_dict = {
                'date': current_date,
                'shift': user_shift,
                'carwasher_name': current_user.full_name,
                'total_gross_sales': float(data.get('total_gross_sales', 0)),
                'forty_x': float(data.get('forty_x', 0)),
                'addons': data.get('addons', {}),  # Dictionary of addon name: amount
                'other_income': data.get('other_income', {}),  # Dictionary of income type: amount
                'expenses': data.get('expenses', {}),  # Dictionary of expense name: {description, amount}
                'wages': float(data.get('wages', 0)),
                'gcash': float(data.get('gcash', 0)),
                'grand_total': float(data.get('grand_total', 0)),
                'created_by': current_user.id
            }

            # Validate required fields
            required_fields = ['total_gross_sales', 'forty_x', 'wages', 'grand_total']
            for field in required_fields:
                if field not in data:
                    return jsonify({"error": f"Missing required field: {field}"}), 400

            # Save to database
            summary_id = add_shift_summary(summary_dict)
            
            return jsonify({
                "message": "Shift summary submitted successfully",
                "id": summary_id,
                "date": current_date,
                "shift": user_shift
            }), 201

        except Exception as e:
            return jsonify({"error": str(e)}), 500

    @app.route("/api/shift-summary", methods=["GET"])
    @require_admin
    def api_get_shift_summaries():
        """Get shift summaries - Admin/Developer only."""
        try:
            # Get query parameters
            date = request.args.get('date')
            shift = request.args.get('shift')
            carwasher_name = request.args.get('carwasher_name')

            if date and shift and carwasher_name:
                # Get specific summary
                summary = get_shift_summary(date, shift, carwasher_name)
                return jsonify(summary), 200
            elif date and shift:
                # Get all summaries for date and shift
                summaries = get_shift_summary(date, shift)
                return jsonify(summaries), 200
            else:
                # Get all summaries with optional filters
                summaries = get_all_shift_summaries(date, shift)
                return jsonify(summaries), 200

        except Exception as e:
            return jsonify({"error": str(e)}), 500



    @app.route("/api/shift-summary-exists", methods=["GET"])
    @require_login
    def api_check_shift_summary_exists():
        """Check if shift summary exists for current user's date/shift."""
        try:
            from datetime import datetime
            current_time = datetime.now()
            current_date = current_time.strftime('%Y-%m-%d')
            
            # Get user's shift
            user_shift = current_user.shift
            if not user_shift:
                # Fallback to time-based shift determination
                user_shift = "AM" if 5 <= current_time.hour < 17 else "PM"
            
            # Check if summary exists
            summary = get_shift_summary(current_date, user_shift, current_user.full_name)
            exists = len(summary) > 0 if isinstance(summary, list) else summary is not None
            
            return jsonify({
                "exists": exists,
                "date": current_date,
                "shift": user_shift,
                "carwasher_name": current_user.full_name
            }), 200
            
        except Exception as e:
            return jsonify({"error": str(e)}), 500


    return app

if __name__ == "__main__":
    create_app().run(debug=True, port=5000)
